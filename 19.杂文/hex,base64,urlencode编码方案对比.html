<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>hex,base64,urlencode编码方案对比 | 一颗牙疼</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.3f8f40ca.css" as="style"><link rel="preload" href="/assets/js/app.45766827.js" as="script"><link rel="preload" href="/assets/js/2.fe0fd2e3.js" as="script"><link rel="preload" href="/assets/js/76.0949c77b.js" as="script"><link rel="prefetch" href="/assets/js/10.1b5e4df9.js"><link rel="prefetch" href="/assets/js/11.8ff4b4c6.js"><link rel="prefetch" href="/assets/js/12.1f666ad7.js"><link rel="prefetch" href="/assets/js/13.4b2c2cdc.js"><link rel="prefetch" href="/assets/js/14.6aff91d2.js"><link rel="prefetch" href="/assets/js/15.73cba6c7.js"><link rel="prefetch" href="/assets/js/16.ad14d937.js"><link rel="prefetch" href="/assets/js/17.83571311.js"><link rel="prefetch" href="/assets/js/18.94ffcfd9.js"><link rel="prefetch" href="/assets/js/19.2bc9699e.js"><link rel="prefetch" href="/assets/js/20.cd11be1e.js"><link rel="prefetch" href="/assets/js/21.f72d8245.js"><link rel="prefetch" href="/assets/js/22.4ab2d9c4.js"><link rel="prefetch" href="/assets/js/23.6fc66197.js"><link rel="prefetch" href="/assets/js/24.b4f56ad5.js"><link rel="prefetch" href="/assets/js/25.09b45bb5.js"><link rel="prefetch" href="/assets/js/26.5ee059a8.js"><link rel="prefetch" href="/assets/js/27.be7547f8.js"><link rel="prefetch" href="/assets/js/28.7344796d.js"><link rel="prefetch" href="/assets/js/29.d13c00a4.js"><link rel="prefetch" href="/assets/js/3.d68f042b.js"><link rel="prefetch" href="/assets/js/30.e031b3b4.js"><link rel="prefetch" href="/assets/js/31.956cd10d.js"><link rel="prefetch" href="/assets/js/32.2dd060e7.js"><link rel="prefetch" href="/assets/js/33.12be6679.js"><link rel="prefetch" href="/assets/js/34.a3340d62.js"><link rel="prefetch" href="/assets/js/35.a93d77cb.js"><link rel="prefetch" href="/assets/js/36.aaa0efd3.js"><link rel="prefetch" href="/assets/js/37.022bfed4.js"><link rel="prefetch" href="/assets/js/38.eac01473.js"><link rel="prefetch" href="/assets/js/39.522847f2.js"><link rel="prefetch" href="/assets/js/4.0b2df6d7.js"><link rel="prefetch" href="/assets/js/40.719d8097.js"><link rel="prefetch" href="/assets/js/41.783cf315.js"><link rel="prefetch" href="/assets/js/42.d6a7272b.js"><link rel="prefetch" href="/assets/js/43.dabb162c.js"><link rel="prefetch" href="/assets/js/44.49bb79c5.js"><link rel="prefetch" href="/assets/js/45.5612ac57.js"><link rel="prefetch" href="/assets/js/46.512917d8.js"><link rel="prefetch" href="/assets/js/47.c53404cd.js"><link rel="prefetch" href="/assets/js/48.c03cb413.js"><link rel="prefetch" href="/assets/js/49.4c4cb399.js"><link rel="prefetch" href="/assets/js/5.96134a61.js"><link rel="prefetch" href="/assets/js/50.9ce3769b.js"><link rel="prefetch" href="/assets/js/51.4d5b8df8.js"><link rel="prefetch" href="/assets/js/52.3eb64378.js"><link rel="prefetch" href="/assets/js/53.59342bf7.js"><link rel="prefetch" href="/assets/js/54.424c8556.js"><link rel="prefetch" href="/assets/js/55.15392b51.js"><link rel="prefetch" href="/assets/js/56.44694980.js"><link rel="prefetch" href="/assets/js/57.ec9db9aa.js"><link rel="prefetch" href="/assets/js/58.adbc8d4a.js"><link rel="prefetch" href="/assets/js/59.7fe5015e.js"><link rel="prefetch" href="/assets/js/6.4cf51f39.js"><link rel="prefetch" href="/assets/js/60.c027b369.js"><link rel="prefetch" href="/assets/js/61.ac98ae59.js"><link rel="prefetch" href="/assets/js/62.6483d84b.js"><link rel="prefetch" href="/assets/js/63.e8ea3651.js"><link rel="prefetch" href="/assets/js/64.d9cd379f.js"><link rel="prefetch" href="/assets/js/65.bcdc7b80.js"><link rel="prefetch" href="/assets/js/66.b9fcbe2d.js"><link rel="prefetch" href="/assets/js/67.c315c8c2.js"><link rel="prefetch" href="/assets/js/68.4bf3525f.js"><link rel="prefetch" href="/assets/js/69.5c3498d7.js"><link rel="prefetch" href="/assets/js/7.661a7c8f.js"><link rel="prefetch" href="/assets/js/70.bbf2a796.js"><link rel="prefetch" href="/assets/js/71.8893f649.js"><link rel="prefetch" href="/assets/js/72.8f6bbd00.js"><link rel="prefetch" href="/assets/js/73.d98a7e5c.js"><link rel="prefetch" href="/assets/js/74.57645762.js"><link rel="prefetch" href="/assets/js/75.5bbb7af6.js"><link rel="prefetch" href="/assets/js/77.a0a048cb.js"><link rel="prefetch" href="/assets/js/78.94c9cdf5.js"><link rel="prefetch" href="/assets/js/79.ca6e3f76.js"><link rel="prefetch" href="/assets/js/8.cbcbaa9c.js"><link rel="prefetch" href="/assets/js/80.829a94f7.js"><link rel="prefetch" href="/assets/js/81.5b6a188e.js"><link rel="prefetch" href="/assets/js/82.0679a421.js"><link rel="prefetch" href="/assets/js/9.9cc097c6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3f8f40ca.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.jpg" alt="一颗牙疼" class="logo"> <span class="site-name can-hide">一颗牙疼</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/01.Java/" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/Atoothache/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/01.Java/" class="nav-link">
  笔记
</a></div><div class="nav-item"><a href="https://github.com/Atoothache/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>服务器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>脚本语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>模板引擎</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>安全认证</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>搜索引擎</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>杂文</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/19.杂文/VMware与主机互通并访问外网.html" class="sidebar-link">VMware虚拟机三种网络模式详解</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/19.杂文/hex,base64,urlencode编码方案对比.html" class="active sidebar-link">hex,base64,urlencode编码方案对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#hex编码" class="sidebar-link">hex编码</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#base64编码" class="sidebar-link">base64编码</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#urlencode编码" class="sidebar-link">urlencode编码</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#两次urlencode解决乱码" class="sidebar-link">两次urlencode解决乱码</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#这些编码有啥用" class="sidebar-link">这些编码有啥用？</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#对比" class="sidebar-link">对比</a></li><li class="sidebar-sub-header"><a href="/19.杂文/hex,base64,urlencode编码方案对比.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/19.杂文/一文弄懂 maven 仓库, 仓库优先级, settings pom配置关系及差异.html" class="sidebar-link">一文弄懂 maven 仓库, 仓库优先级, settings pom配置关系及差异</a></li><li><a href="/19.杂文/使用GoogleKaptcha 生成验证码.html" class="sidebar-link">使用GoogleKaptcha 生成验证码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/19.杂文/博客.html" class="sidebar-link">博客</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/19.杂文/博客.html#为什么你需要一个博客" class="sidebar-link">为什么你需要一个博客？</a></li><li class="sidebar-sub-header"><a href="/19.杂文/博客.html#什么是-vuepress-为什么要使用-vuepress" class="sidebar-link">什么是 VuePress，为什么要使用 VuePress ？</a></li><li class="sidebar-sub-header"><a href="/19.杂文/博客.html#为什么不是" class="sidebar-link">为什么不是...?</a></li></ul></li><li><a href="/19.杂文/正向代理yu反向代理.html" class="sidebar-link">nginx 正向代理yu反向代理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/19.杂文/正向代理yu反向代理.html#nginx-正向代理yu反向代理" class="sidebar-link">nginx 正向代理yu反向代理</a></li></ul></li><li><a href="/19.杂文/网站推荐.html" class="sidebar-link">网站推荐</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="hex-base64-urlencode编码方案对比"><a href="#hex-base64-urlencode编码方案对比" class="header-anchor">#</a> hex,base64,urlencode编码方案对比</h1> <h2 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h2> <p>在工作过程中，我们慢慢会了解到hex、base64、urlencode这3种常见的字节编码方案，它们是如此的熟悉，可是经常我们自己也说不清为啥要使用它们，下面我会详细解释下。</p> <h2 id="hex编码"><a href="#hex编码" class="header-anchor">#</a> hex编码</h2> <p>hex编码，又称十六进制编码(也称base16)，一般用于方便人们查看二进制文件内容，它将字节数据中的每4个bit使用数字(0-9)、字母(A-F)共16个字符等效表示，由于一个字节有8个bit，所以一个字节会被编码为2个hex字符，具体规则如下：</p> <p><img src="https:////upload-images.jianshu.io/upload_images/3629585-5ce1ce856337e94e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp" alt="img"></p> <p>image_2021-09-05_hex_codec.jpg</p> <p>Linux中可使用xxd来做hex编解码，如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># abc这3个英文字符会被echo编码为3个字节，然后被xxd编码为6个hex字符</span>
$ <span class="token builtin class-name">echo</span> -n abc<span class="token operator">|</span>xxd -ps
<span class="token number">616263</span> 
<span class="token comment"># 解码hex数据</span>
$ <span class="token builtin class-name">echo</span> <span class="token number">616263</span><span class="token operator">|</span>xxd -ps -r
abc
</code></pre></div><h2 id="base64编码"><a href="#base64编码" class="header-anchor">#</a> base64编码</h2> <p>base64编码，它将字节数据中的每6个bit使用字母(a-zA-Z)、数字(0-9)、+、/总共64个字符等效表示，故每3个字节(8bit)会被编码为4个base64中的字符。
由于数据中的字节数不一定是3的整数倍，当字节数对3求模后，多1个字节时，那个字节会被编码为2个字符加2个=号(填充字符)，多2个字节时，这2个字节会被编码为3个字符加1个=号(填充字符)，刚好整除时，则不需要=号填充，具体规则如下：</p> <p><img src="https:////upload-images.jianshu.io/upload_images/3629585-0622cbb7c0c2fd86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="img"></p> <p>image_2021-09-05_base64_codec.jpg</p> <p>Linux下可以使用base64这个命令做base64编解码</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token comment"># 3个字母等于3个字节，所以会编码为4个base64字符，并没有=号</span>
$ <span class="token builtin class-name">echo</span> -n abc <span class="token operator">|</span> base64
YWJj 
<span class="token comment"># 1个字节会被编码为2个base64字符，另加2个=号填充</span>
$ <span class="token builtin class-name">echo</span> -n a <span class="token operator">|</span> base64
<span class="token assign-left variable">YQ</span><span class="token operator">==</span>
<span class="token comment"># 2个字节会被编码为3个base64字符，另加1个=号填充</span>
$ <span class="token builtin class-name">echo</span> -n ab<span class="token operator">|</span>base64
<span class="token assign-left variable">YWI</span><span class="token operator">=</span>
<span class="token comment"># 解码base64数据</span>
$ <span class="token builtin class-name">echo</span> <span class="token assign-left variable">YWI</span><span class="token operator">=</span> <span class="token operator">|</span> base64 -d
ab
</code></pre></div><p>另外，base64编码有一些常见的变种，以下3种是常见的：</p> <ol><li><p>MimeBase64
每76个字符后会添加换行符<code>\r\n</code>，便于阅读。</p></li> <li><p>UrlBase64
由于Base64编码使用了<code>+ /</code>两个字符，这与url命名规则冲突(<code>/</code>在url中是路径分隔符，<code>+</code>会被urldecode为空格字符)，这个变种将<code>+ /</code>这两个字符更换为<code>- _</code>，如下：</p> <p><img src="https:////upload-images.jianshu.io/upload_images/3629585-ac692c08d834d716.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="img"></p> <p>image_2021-09-05_base64_urlsafe_codec.jpg</p></li> <li><p>NoPaddingBase64
由于Base64编码是对6bit进行编码，数据以8bit存储，当字节数不是3的整数倍时需要=号填充，这种方案就是去掉了=号，从上面的编码示例中也可以看出，加=号填充纯粹是为了保持base64编码字符串长度为4的整数倍，去掉=号其实不影响解析。</p></li></ol> <h2 id="urlencode编码"><a href="#urlencode编码" class="header-anchor">#</a> urlencode编码</h2> <p>urlencode编码，看名字就知道是设计用来给url编码的，对于<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，<code>.</code>，<code>-</code>和<code>_</code> ，urlencode都不会做任何处理原样输出，而其它字节会被编码为<code>%xx</code>(16进制)的形式，其中<code>xx</code>就是这个字节对应的hex编码。</p> <p>Linux下<code>gridsite-clients</code>包实现了urlencode命令，如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> gridsite-clients
$ urlencode <span class="token string">'a b'</span>
a%20b
$ urlencode -d a%20b
a b
</code></pre></div><p>使用python也很容易实现urlencode，可将其定义为 Linux 命名别名，方便使用，如下：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token builtin class-name">alias</span> <span class="token assign-left variable">urlencode</span><span class="token operator">=</span><span class="token string">'python -c &quot;import sys, urllib as ul; print ul.quote_plus(sys.argv[1])&quot;'</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">urldecode</span><span class="token operator">=</span><span class="token string">'python -c &quot;import sys, urllib as ul; print ul.unquote_plus(sys.argv[1])&quot;'</span>
</code></pre></div><p>另外，不同的urlencode实现上也有些差异，比如某些urlencode会将<code>空格</code>编码为<code>+</code>(W3C标准规定)，而另外一些实现中，<code>空格</code>会被编码为<code>%20</code>(RFC 2396)。</p> <blockquote><p>注：java中的URLEncoder、javascript中的encodeURIComponent、html表单提交中的application/x-www-form-urlencode，这些都会将空格编码为<code>+</code>，而一些web服务器在进行某些urldecode时会不认识<code>+</code>号，所以在使用这些函数进行urlencode编码时，最好将编码后的<code>+</code>替换为<code>%20</code>，如<code>URLEncoder.encode(bytes, &quot;UTF-8&quot;).replace(&quot;+&quot;, &quot;%20&quot;)</code></p></blockquote> <h2 id="两次urlencode解决乱码"><a href="#两次urlencode解决乱码" class="header-anchor">#</a> 两次urlencode解决乱码</h2> <p>在最开始遇到乱码问题时，在网上搜到一种 “客户端两次urlencode，服务端一次urldecode” 的乱码解决方案，并声称这样能彻底解决乱码。
然后很长一段时间我都是这样实践的，但一直不知道为什么，直到有一次我调试乱码问题调试到tomcat里面去才发现真相，原来web服务器对url都会自动做一次urldecode，urldecode后的字节使用server.xml中配置的uri-encoding字符编码转换成字符串，而如果uri-encoding这个字符编码配置与客户端使用的不同，就会出现乱码，下面用2个示例模拟一下：</p> <ol><li>客户端使用UTF-8进行一次urlencode，服务端tomcat使用uri-encoding的默认编码ISO-8859-1为例：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> sendParam <span class="token operator">=</span> <span class="token string">&quot;好&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 使用UTF-8进行urlencode，'好'编码为 %E5%A5%BD</span>
<span class="token class-name">String</span> urlencodeSendParam <span class="token operator">=</span> <span class="token class-name">URLEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>sendParam<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//....这里表示数据从客户端传至服务端</span>
<span class="token class-name">String</span> urlencodeReceivedParam <span class="token operator">=</span> urlencodeSendParam<span class="token punctuation">;</span>
<span class="token comment">// 使用ISO-8859-1进行urldecode后，%E5%A5%BD解码为乱码 å¥½ ，注意这个解码是web服务器自动进行的</span>
<span class="token class-name">String</span> receivedParam <span class="token operator">=</span> <span class="token class-name">URLDecoder</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>urlencodeReceivedParam<span class="token punctuation">,</span> <span class="token string">&quot;ISO-8859-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 会输出乱码 å¥½</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>receivedParam<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol><li>如果客户端做两次urlencode，服务端做一次urldecode，过程如下：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> sendParam <span class="token operator">=</span> <span class="token string">&quot;好&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// 使用UTF-8进行urlencode，'好'编码为%E5%A5%BD</span>
<span class="token class-name">String</span> urlencodeSendParam <span class="token operator">=</span> <span class="token class-name">URLEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>sendParam<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 再使用UTF-8进行urlencode，%E5%A5%BD 编码为 %25E5%25A5%25BD</span>
<span class="token class-name">String</span> urlencodeSendParam2 <span class="token operator">=</span> <span class="token class-name">URLEncoder</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>urlencodeSendParam<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//....这里表示数据从客户端传至服务端</span>
<span class="token class-name">String</span> urlencodeReceivedParam2 <span class="token operator">=</span> urlencodeSendParam2<span class="token punctuation">;</span>
<span class="token comment">// 使用ISO-8859-1进行urldecode后，%25E5%25A5%25BD 解码为%E5%A5%BD，注意这个解码是web服务器自动进行的</span>
<span class="token class-name">String</span> urlencodeReceivedParam <span class="token operator">=</span> <span class="token class-name">URLDecoder</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>urlencodeReceivedParam2<span class="token punctuation">,</span> <span class="token string">&quot;ISO-8859-1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用UTF-8进行urldecode后，%E5%A5%BD解码为'好'</span>
<span class="token class-name">String</span> receivedParam <span class="token operator">=</span> <span class="token class-name">URLDecoder</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>urlencodeReceivedParam<span class="token punctuation">,</span> <span class="token string">&quot;UTF-8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 会输出正确的'好'字</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>receivedParam<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>从上面的两个示例中，应该不难看出，之所以前端2次编码，后端1次解码不会出现乱码，是因为前端在第1次urlencode后，数据就已经变成了纯英文，而纯英文先使用UTF-8的urlencode编码，再使用ISO-8859-1的urldecode解码，是可以完全还原数据的。另外，由于服务端的第二次urldecode是你自己写的，字符编码当然会和前端使用一致的UTF-8，故<code>好</code>字被无误的还原回来了。</p> <p>为什么说英文可以先使用UTF-8的urlencode编码，再使用ISO-8859-1的urldecode解码呢？原因是java中的<code>URLEncoder</code>类其实是做了两件事，先使用字符编码将字符串转换为字节，然后对字节进行urlencode编码，因为urlencode算法本质作用就是将字节数据编码为等效的英文字符表示，只不过<code>URLEncoder</code>类将其封装为一步了，等效代码如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 1. 使用字符编码，将字符串转换为字节串，因为urlencode是用来处理字节数据的</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>charset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 将字节数据，使用urlencode算法，编码为英文字符串</span>
<span class="token class-name">String</span> urlencodeStr <span class="token operator">=</span> <span class="token function">urlencode</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而对于UTF-8与ISO-8859-1来说，它们都是兼容ASCII码的，所以对于纯英文的urlencode编解码，编码数据是可以正确解码的，不信你可以把ISO-8859-1变成UTF-16试试，由于UTF-16是不兼容ASCII的，所以上面的方案处理后依然为乱码。</p> <p>ps，虽然这种方案基本可以完美解决乱码(基于大多数主流字符编码兼容ASCII)，但由于第二次urlencode编码又会将<code>%</code>编码为<code>%25</code>，使得数据体积增大不少，所以非必要情况下，还是不要滥用比较好，能都用UTF-8就都用UTF-8吧。我以前经历过的项目都比较奇葩，多种编码混搭，才导致我要如此了解编码机制<code>[-_-]</code>。</p> <h2 id="这些编码有啥用"><a href="#这些编码有啥用" class="header-anchor">#</a> 这些编码有啥用？</h2> <p>这些编码的本质作用都是将字节数据转换为等效的纯英文形式，主要用在那些不方便查看、存储或传输原始字节数据的地方。
比如在html中，因为html本身就是纯文本的，不能直接放入原始字节数据，这时，我们可以将一些小图标(非文本数据)通过base64编码的方式内嵌到html中，以使得html页面与图标数据能在一次网络交互中返回，这种方案也称Data URI。</p> <h2 id="对比"><a href="#对比" class="header-anchor">#</a> 对比</h2> <ol><li>hex编码
就算原文件是纯英文内容，编码后内容也和原文完全不一样，普通人难以阅读，但由于只有16个字符，听说一些程序员大牛能够记下他们的映射关系，从而达到读hex编码和读原文一样的效果。另外，数据在经过hex编码后，空间占用变成了原来的2倍。</li> <li>base64编码
由64个字符组成，比hex编码更难阅读，但由于每3个字节会被编码为4个字符，所以，空间占用会是原来的4/3，比hex要节省空间。另外要注意的是，虽然Base64编码后的数据难以阅读，但不能将其做为加密算法使用，因为它解码都不需要你提供密钥啊。</li> <li>urlencode编码
由于英文字符原样保留，对于以英文为主的内容，可读性最好，空间占用几乎不变，而对于非英文内容，每个字节会被编码为%xx的3个字符，空间占用是原来的3倍，所以urlencode是一个对英文友好的编码方案。</li></ol> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>除了hex,base64,urlencode编码之外，其实还有base32,base58这样的编码，但它们只是编码方式不同罢了，本质作用是相同的，即<code>将字节数据转换为等效的纯英文表示，方便传输与存储</code>。<a href="https://www.jianshu.com/p/4d701c09d44e" target="_blank" rel="noopener noreferrer">链接<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/19.杂文/VMware与主机互通并访问外网.html" class="prev">
        VMware虚拟机三种网络模式详解
      </a></span> <span class="next"><a href="/19.杂文/一文弄懂 maven 仓库, 仓库优先级, settings pom配置关系及差异.html">
        一文弄懂 maven 仓库, 仓库优先级, settings pom配置关系及差异
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.45766827.js" defer></script><script src="/assets/js/2.fe0fd2e3.js" defer></script><script src="/assets/js/76.0949c77b.js" defer></script>
  </body>
</html>

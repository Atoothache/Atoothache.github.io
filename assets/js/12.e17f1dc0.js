(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{283:function(t,n,e){"use strict";e.r(n);var r=e(13),s=Object(r.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"信号驱动io-vs-异步io"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动io-vs-异步io"}},[t._v("#")]),t._v(" 信号驱动IO VS 异步IO")]),t._v(" "),n("p",[t._v("一、信号驱动IO模型\n在IO复用模型的学习中，我们已经知道IO 复用模型在第一个阶段和第二个阶段其实都有阻塞，第一个阶段阻塞于 select 调用，第二个阶段阻塞于数据复制。那有没有办法在第一个阶段或者第二个阶段不阻塞，进一步提升性能呢？答案是信号驱动IO模型，其流程图如下所示。")]),t._v(" "),n("p",[t._v("进程发起一个IO操作，会向内核注册一个信号处理程序，然后立即返回不阻塞，当内核将数据报准备好后会发送一个信号给进程，这时候进程便可以在信号处理程序中调用IO处理数据报。")]),t._v(" "),n("p",[t._v("注意：它与IO复用模型的主要区别是等待数据阶段无阻塞。")]),t._v(" "),n("p",[t._v("优点：采用回调机制，等待数据阶段无阻塞；适用于高并发应用程序。\n缺点：模型较为复杂，实现起来有点儿困难。\n举例：因为奶茶店例子的整个周期太短，无法数据复制阶段的阻塞。现在我们换个例子，你和你女朋友在海底捞点完餐后，把电话号码留下，别人做好了直接打电话给你，这时候你们过来，服务员在给你们上菜（数据复制阶段阻塞，你们要等服务员把菜拿到你们的桌子上）。菜没准备完的期间，你和你女朋友可以一直逛商场，时间就更多了。")]),t._v(" "),n("p",[t._v("二、异步IO模型\n经过了一系列优化，终于不用在数据等待阶段阻塞了，但是在数据复制节点依然是阻塞的，所以如果我们需要进一步优化的话，只需要把数据复制阶段也优化为异步，我们就大功告成了，也就变成了真正的异步IO了。")]),t._v(" "),n("p",[t._v("当进程发送一个IO操作，进程会立刻返回（不阻塞），内核会把整个IO数据报准备和复制好后，再通知进程，进程再处理数据报，这样在数据复制阶段也不会发生阻塞。")]),t._v(" "),n("p",[t._v("优点：整个过程都不阻塞，一步到位；非常使用高并发应用\n缺点：模型复杂，实现、开发难度较大\n举例：你们现在连上菜的时间也不想等，就想直接开吃。于是你和你女朋友在海底捞点完餐后，把电话号码留下，要求服务员菜准备完了直接拿到餐桌上，然后打电话给你，这时候你们过来就可以直接开吃了。")]),t._v(" "),n("p",[t._v("总结\n五种IO模型，层层递进，一个比一个性能高，当然模型的复杂度也一个比一个复杂。在学习IO模型的过程中我们也可以看出，我们解决的其实就是如何优化数据等待阶段和数据复制阶段这两个问题。\n最后，用一张图总结五种IO模型的区别。\n"),n("a",{attrs:{href:"https://blog.csdn.net/qq_52173163/article/details/125957438",target:"_blank",rel:"noopener noreferrer"}},[t._v("原文链接"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=s.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{354:function(e,n,t){"use strict";t.r(n);var s=t(13),r=Object(s.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"docker离线安装部署"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#docker离线安装部署"}},[e._v("#")]),e._v(" Docker离线安装部署")]),e._v(" "),n("p",[e._v("docker安装包下载地址："),n("a",{attrs:{href:"https://download.docker.com/linux/static/stable/x86_64/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://download.docker.com/linux/static/stable/x86_64/"),n("OutboundLink")],1)]),e._v(" "),n("h1",{attrs:{id:"创建系统配置文件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建系统配置文件"}},[e._v("#")]),e._v(" 创建系统配置文件")]),e._v(" "),n("p",[n("strong",[e._v("创建文件：")])]),e._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[e._v("vim")]),e._v(" /opt/docker/docker.service\n")])])]),n("p",[n("strong",[e._v("内容如下：")])]),e._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Unit"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Description")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("Docker Application Container Engine\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Documentation")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("https://docs.docker.com\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("After")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("network-online.target firewalld.service\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Wants")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("network-online.target\n\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Service"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Type")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("notify\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the default is not to use systemd for cgroups because the delegate issues still")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# exists and systemd currently does not support the cgroup feature set required")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for containers run by docker")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("ExecStart")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("/usr/bin/dockerd\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("ExecReload")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("/bin/kill -s HUP "),n("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$MAINPID")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Having non-zero Limit*s causes performance problems due to accounting overhead")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the kernel. We recommend using cgroups to do container-local accounting.")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitNOFILE")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitNPROC")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitCORE")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Uncomment TasksMax if your systemd version supports it.")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Only systemd 226 and above support this version.")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#TasksMax=infinity")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("TimeoutStartSec")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# set delegate yes so that systemd does not reset the cgroups of docker containers")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Delegate")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("yes\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# kill only the docker process, not all processes in the cgroup")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("KillMode")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("process\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# restart the docker process if it exits prematurely")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Restart")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("on-failure\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("StartLimitBurst")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("StartLimitInterval")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("60s\n\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Install"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("WantedBy")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("multi-user.target\n")])])]),n("p",[e._v("创建安装脚本")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("vim /opt/docker/install.sh\n")])])]),n("p",[e._v("内容如下：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("#!/bin/sh\necho '解压tar包...'\ntar -xvf $1\necho '将docker目录移到/usr/bin目录下...'\ncp docker/* /usr/bin/\necho '将docker.service 移到/etc/systemd/system/ 目录...'\ncp docker.service /etc/systemd/system/\necho '添加文件权限...'\nchmod +x /etc/systemd/system/docker.service\necho '重新加载配置文件...'\nsystemctl daemon-reload\necho '启动docker...'\nsystemctl start docker\necho '设置开机自启...'\nsystemctl enable docker.service\necho 'docker安装成功...'\ndocker -v\n")])])]),n("h4",{attrs:{id:"创建卸载脚本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#创建卸载脚本"}},[e._v("#")]),e._v(" 创建卸载脚本")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("vim /opt/docker/uninstall.sh\n")])])]),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token shebang important"}},[e._v("#!/bin/sh")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'删除docker.service...'")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" -f /etc/systemd/system/docker.service\n"),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'删除docker文件...'")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" -rf /usr/bin/docker*\n"),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'重新加载配置文件'")]),e._v("\nsystemctl daemon-reload\n"),n("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'卸载成功...'")]),e._v("\n")])])]),n("p",[n("strong",[e._v("执行安装脚本：")])]),e._v(" "),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[n("span",{pre:!0,attrs:{class:"token function"}},[e._v("sh")]),e._v(" install.sh docker-20.10.9.tgz\n")])])]),n("h1",{attrs:{id:"配置国内源"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#配置国内源"}},[e._v("#")]),e._v(" 配置国内源")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('vim /etc/docker/daemon.json\n\n{\n "registry-mirrors" : [\n   "https://mirror.ccs.tencentyun.com",\n   "http://registry.docker-cn.com",\n   "http://docker.mirrors.ustc.edu.cn",\n   "http://hub-mirror.c.163.com"\n ],\n "insecure-registries" : [\n   "registry.docker-cn.com",\n   "docker.mirrors.ustc.edu.cn"\n ],\n "debug" : true,\n "experimental" : true\n}\n')])])]),n("div",{staticClass:"language-shell extra-class"},[n("pre",{pre:!0,attrs:{class:"language-shell"}},[n("code",[e._v("systemctl daemon-reload\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#重启docker")]),e._v("\nsystemctl restart docker.service\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("安装过程遇到的问题：\n1、现象\n\n使用systemctl start docker启动很慢，并且呈现卡死状态，无任何反应。\n\n使用systemctl status docker发现docker一直处于Active: activating (start)\n\n2、可能的原因\n 服务器重启之后防火墙先于docker重启，docker无法操作防火墙导致重启卡死。\n\n3、解决方法\n\n关闭防火墙systemctl stop firewalld并查看关闭情况\n重启服务器\n启动docker systemctl start docker 并查看启动情况\n开启防火墙 systemctl start firewalld\n\n————————————————\n\n版权声明：本文为CSDN博主「一恍过去」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n\n原文链接：https://blog.csdn.net/zhuocailing3390/article/details/121797180\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("先介绍一下虚拟机的网络模式\n生成的虚拟设备\n\nVMnet0：用于虚拟桥接网络下的虚拟交换机\nVMnet1：用于虚拟Host-Only网络下的虚拟交换机\nVMnet8：用于虚拟NAT网络下的虚拟交换机\nVMware NetworkAdepter VMnet1：Host用于与Host-Only虚拟网络进行通信的虚拟网卡\nVMware NetworkAdepter VMnet8：Host用于与NAT虚拟网络进行通信的虚拟网卡\n\n一般具有这样的对应关系\n桥接\n在这种模式下，VMware虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。\n\nNAT\n使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，不需要进行任何其他的配置，只需要主机器能访问互联网即可。这种情况下，主机可以ping通虚拟机，虚拟机也能ping通主机。\nHost-Only\nHost-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。\n\n关于docker的网络模式\ndocker使用linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。\n\n由于docker网桥是虚拟出来的，外部网络无法寻址到 ，也就是说外部网络无法直接通过container_ip来访问容器，此时就需要使用端口映射（映射容器端口到宿主主机），docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器\n\n四种网络模式总览\n\nhost模式 –net=host 容器和宿主机共享Network namespace。\ncontainer模式 –net=container:NAME_or_ID 容器和另外一个容器共享Network namespace。\nnone模式 –net=none 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。\nbridge模式 –net=bridge （默认为该模式）\nHost模式\n容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。\n\n使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。\n\ncontainer模式\n指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nZgeXJwP-1652531930546)(D:\\Utilities\\Typora\\images\\webp)]\n\nnone模式\nnone模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。\n\nbridge模式\n当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。\n\n从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。\n\nbridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。\n————————————————\n版权声明：本文为CSDN博主「LRY01127」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_56416440/article/details/124773678\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("安装oracle:\n docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n \n docker run -d --name oracle --net=host registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n \n docker exec -it oracle bash\n 切到root用户\n su \n \n helowin\n \n cd /home/oracle/app/oracle/product/11.2.0/dbhome_2/\n \n 配置环境变量\n vi /etc/profile\n加在最下面\nexport ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2/\nexport ORACLE_SID=helowin\nexport PATH=$PATH:$ORACLE_HOME/bin\n刷新环境变量\nsource /etc/profile\n切回oracle用户\nsu - oracle\n\n登录sqlplus\nsqlplus /nolog\n连接数据库用户\nSQL> conn /as sysdba;\n修改system用户\nalter user system identified by 123456;\nalter user sys identified by 123456;\nalter profile default limit PASSWORD_LIFE_TIME unlimited;\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("安装mysql：\ndocker pull mysql:8.0\n\nmkdir -p /data/mysql/log\nmkdir -p /data/mysql/data\nmkdir -p /data/mysql/conf\nvim /data/mysql/conf/my.cnf\n\n[client]\ndefault-character-set=utf8mb4\n[mysql]\ndefault-character-set=utf8mb4\n[mysqld]\ncharacter-set-server=utf8mb4\ndefault-time-zone=+8:00\nsecure_file_priv=NULL\nmax_allowed_packet=2G\n\ndocker run -p 3306:3306 --name mysql8 --privileged=true -v /data/mysql/log:/var/log/mysql:rw -v /data/mysql/data:/var/lib/mysql:rw -v /data/mysql/conf:/etc/mysql/conf.d:rw  -v /etc/localtime:/etc/localtime:ro -e MYSQL_ROOT_PASSWORD=faduitdragon -d mysql:8.0\n\n\n三、连接MySQL\n1、进入mysql容器\ndocker exec -it mysql /bin/bash\n\n2、登陆mysql\nmysql -u root -p\n\n3、mysql 8 设置允许远程用户访问\nuse mysql;\nupdate user set host = '%' where user = 'root' and host='localhost'; # 更新root - localhost 为 root - %\n\nGRANT ALL ON *.* TO 'root'@'%'; # 设置允许远程用户访问\n\nflush privileges;# 刷新权限\n\nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '密码';#更新用户加密方式，mysql8默认的加密方式为caching_sha2_password 与mysql5的加密方式mysql_native_password 不同\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("nginx安装 (nginx最新版本不包含SSL模块   1.23.4版本包含)\ndocker pull nginx\nmkdir -p /data/nginx/conf.d\nvi /data/nginx/conf.d/80.conf\n\nserver{\n        listen 80;\n\n        location / {\n                root /usr/share/nginx/html;\n        }\n}\n\n\ndocker run -d --name nginx --net=host --privileged -v /data/nginx/conf.d/:/etc/nginx/conf.d nginx\n\ndocker run -d --name nginx-web --net=host --privileged  -v /docker/nginx/cert:/etc/nginx/cert -v /docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /docker/nginx/html:/usr/share/nginx/html -v /docker/nginx/log:/var/log/nginx  nginx:1.23.4\n\ndocker run -d --name nginx --net=host --privileged  -v /data/nginx/cert:/etc/nginx/cert  -v /data/nginx/conf:/etc/nginx -v /data/nginx/html:/usr/share/nginx/html -v /data/nginx/log:/var/log/nginx  nginx:1.20.1\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("rabbitmq 安装\n\ndocker pull rabbitmq:3.8.25-management\ndocker run -d --name rabbitmq -p 15672:15672 -p 5672:5672 rabbitmq:3.8.25-management\ndocker run -d --name rabbitmq --net=host rabbitmq:3.8.25-management\n\n通过docker ps -a查看部署的mq容器id，在通过 docker exec -it 容器id /bin/bash 进入容器内部在\n运行：rabbitmq-plugins enable rabbitmq_management\n\n主要端口介绍\n4369 -- erlang发现口\n5672 -- client端通信口\n15672 -- 管理界面ui端口\n25672 -- server间内部通信口\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("redis 安装\n\ndocker pull redis\n\nmkdir /data/redis\ncd /data/redis\nwget http://download.redis.io/redis-stable/redis.conf\nchmod 777 redis.conf\nvi /data/redis/redis.conf\n\nbind 127.0.0.1 通过#注释掉，解除本地连接限制\nprotected-mode yes 默认no，保护模式，限制为本地访问，修改后解除保护模式\nrequirepass设置密码（建议设置，不设置有风险）\n\ndocker启动redis命令\n\ndocker run -p 6379:6379 --name redis --privileged=true  -v /data/redis/redis.conf:/etc/redis/redis.conf  -v /data/redis/data:/data -d redis redis-server /etc/redis/redis.conf\n\n命令分析\n\n-p 6379:6379 端口映射：前表示主机部分，：后表示容器部分。\n\n–name redis 指定该容器名称，查看和进行操作都比较方便。\n\n-v 挂载文件或目录 ：前表示主机部分，：后表示容器部分。\n\n-d redis 表示后台启动redis\n\nredis-server /etc/redis/redis.conf\n以配置文件启动redis，加载容器内的conf文件，最终找到的是挂载的目录/usr/local/docker/redis.conf\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("jenkins安装\ndocker pull jenkins/jenkins:lts\ndocker run -d -p 18080:8080 -p 50000:50000 -v /docker/jenkins/jenkins_mount:/var/jenkins_home -v /etc/localtime:/etc/localtime --name jenkins jenkins/jenkins:lts\n\n\n\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('minio安装\ndocker run -p 9000:9000 -p 9090:9090 --name minio  -d --restart=always  -e "MINIO_ACCESS_KEY=admin"  -e "MINIO_SECRET_KEY=0405@nan.minio" -v /data/minio/data:/data bitnami/minio  server /data --console-address ":9090" -address ":9000"\n\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('rocketmq\n\n拉取镜像\ndocker pull rocketmqinc/rocketmq\n1\n创建namesrv数据存储路径\nmkdir -p  /docker/rocketmq/data/namesrv/logs   /docker/rocketmq/data/namesrv/store\n1\n构建namesrv容器\ndocker run -d \\\n--restart=always \\\n--name rmqnamesrv \\\n-p 9876:9876 \\\n-v /docker/rocketmq/data/namesrv/logs:/root/logs \\\n-v /docker/rocketmq/data/namesrv/store:/root/store \\\n-e "MAX_POSSIBLE_HEAP=100000000" \\\nrocketmqinc/rocketmq \\\nsh mqnamesrv \n\n参数\t说明\n-d\t以守护进程的方式启动\n-restart=always| docker重启时候容器自动重启\n-name rmqnamesrv | 把容器的名字设置为rmqnamesrv\n-p 9876:9876| 把容器内的端口9876挂载到宿主机9876上面\n-v /docker/rocketmq/data/namesrv/logs:/root/logs | 把容器内的/root/logs日志目录挂载到宿主机的 /docker/rocketmq/data/namesrv/logs目录\n-v /docker/rocketmq/data/namesrv/store:/root/store | 把容器内的/root/store数据存储目录挂载到宿主机的 /docker/rocketmq/data/namesrv目录\nrmqnamesrv | 容器的名字\n-e “MAX_POSSIBLE_HEAP=100000000” | 设置容器的最大堆内存为100000000\nrocketmqinc/rocketmq | 使用的镜像名称\nsh mqnamesrv | 启动namesrv服务\n2.创建broker节点\n创建broker数据存储路径\nmkdir -p  /docker/rocketmq/data/broker/logs   /docker/rocketmq/data/broker/store /docker/rocketmq/conf\n1\n创建配置文件\nvi /docker/rocketmq/conf/broker.conf\n# 所属集群名称，如果节点较多可以配置多个\nbrokerClusterName = DefaultCluster\n#broker名称，master和slave使用相同的名称，表明他们的主从关系\nbrokerName = broker-a\n#0表示Master，大于0表示不同的slave\nbrokerId = 0\n#表示几点做消息删除动作，默认是凌晨4点\ndeleteWhen = 04\n#在磁盘上保留消息的时长，单位是小时\nfileReservedTime = 48\n#有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；\nbrokerRole = ASYNC_MASTER\n#刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；\nflushDiskType = ASYNC_FLUSH\n# 设置broker节点所在服务器的ip地址\nbrokerIP1 = 192.168.52.136\n# 磁盘使用达到95%之后,生产者再写入消息会报错 CODE: 14 DESC: service not available now, maybe disk full\ndiskMaxUsedSpaceRatio=95\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n构建broker容器\ndocker run -d  \\\n--restart=always \\\n--name rmqbroker \\\n--link rmqnamesrv:namesrv \\\n-p 10911:10911 \\\n-p 10909:10909 \\\n-v  /docker/rocketmq/data/broker/logs:/root/logs \\\n-v  /docker/rocketmq/data/broker/store:/root/store \\\n-v /docker/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf \\\n-e "NAMESRV_ADDR=namesrv:9876" \\\n-e "MAX_POSSIBLE_HEAP=200000000" \\\nrocketmqinc/rocketmq \\\nsh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf \n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n参数\t说明\n-d\t以守护进程的方式启动\n–restart=always\tdocker重启时候镜像自动重启\n-name rmqbroker | 把容器的名字设置为rmqbroker\n–link rmqnamesrv:namesrv | 和rmqnamesrv容器通信\n-p 10911:10911 | 把容器的非vip通道端口挂载到宿主机\n-p 10909:10909 | 把容器的vip通道端口挂载到宿主机\n-e “NAMESRV_ADDR=namesrv:9876” | 指定namesrv的地址为本机namesrv的ip地址:9876\n-e “MAX_POSSIBLE_HEAP=200000000” rocketmqinc/rocketmq sh mqbroker | 指定broker服务的最大堆内存\nrocketmqinc/rocketmq | 使用的镜像名称\nsh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf | 指定配置文件启动broker节点\n3.创建rockermq-console服务\n拉取镜像\ndocker pull pangliang/rocketmq-console-ng\n1\n构建rockermq-console容器\n需要把192.168.52.136换成部署namesrv机器地址\n\ndocker run -d \\\n--restart=always \\\n--name rmqadmin \\\n-e "JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.52.136:9876 \\\n-Dcom.rocketmq.sendMessageWithVIPChannel=false" \\\n-p 9999:8080 \\\npangliang/rocketmq-console-ng\n1\n2\n3\n4\n5\n6\n7\n参数\t说明\n-d\t以守护进程的方式启动\n-restart=always| docker重启时候镜像自动重启\n-name rmqadmin | 把容器的名字设置为rmqadmin\n-e “JAVA_OPTS=-Drocketmq.namesrv.addr=192.168.52.136:9876 | 设置namesrv服务的ip地址\n-Dcom.rocketmq.sendMessageWithVIPChannel=false” | 不使用vip通道发送消息\n–p 9999:8080 | 把容器内的端口8080挂载到宿主机上的9999端口\n需要关闭防火墙或者开放namesrv和broker端口\n\n\n')])])]),n("p",[n("a",{attrs:{href:"https://blog.csdn.net/chenjun_base/article/details/120996109",target:"_blank",rel:"noopener noreferrer"}},[e._v("(35条消息) 虚拟机中Linux扩容硬盘空间_chenjun_base的博客-CSDN博客_linux虚拟机扩容"),n("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=r.exports}}]);
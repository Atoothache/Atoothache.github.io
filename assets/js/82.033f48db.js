(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{352:function(a,s,t){"use strict";t.r(s);var e=t(13),n=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"hex-base64-urlencode编码方案对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hex-base64-urlencode编码方案对比"}},[a._v("#")]),a._v(" hex,base64,urlencode编码方案对比")]),a._v(" "),s("h2",{attrs:{id:"简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),s("p",[a._v("在工作过程中，我们慢慢会了解到hex、base64、urlencode这3种常见的字节编码方案，它们是如此的熟悉，可是经常我们自己也说不清为啥要使用它们，下面我会详细解释下。")]),a._v(" "),s("h2",{attrs:{id:"hex编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hex编码"}},[a._v("#")]),a._v(" hex编码")]),a._v(" "),s("p",[a._v("hex编码，又称十六进制编码(也称base16)，一般用于方便人们查看二进制文件内容，它将字节数据中的每4个bit使用数字(0-9)、字母(A-F)共16个字符等效表示，由于一个字节有8个bit，所以一个字节会被编码为2个hex字符，具体规则如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/3629585-5ce1ce856337e94e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/438/format/webp",alt:"img"}})]),a._v(" "),s("p",[a._v("image_2021-09-05_hex_codec.jpg")]),a._v(" "),s("p",[a._v("Linux中可使用xxd来做hex编解码，如下：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# abc这3个英文字符会被echo编码为3个字节，然后被xxd编码为6个hex字符")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" -n abc"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("xxd -ps\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("616263")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 解码hex数据")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("616263")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("xxd -ps -r\nabc\n")])])]),s("h2",{attrs:{id:"base64编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#base64编码"}},[a._v("#")]),a._v(" base64编码")]),a._v(" "),s("p",[a._v("base64编码，它将字节数据中的每6个bit使用字母(a-zA-Z)、数字(0-9)、+、/总共64个字符等效表示，故每3个字节(8bit)会被编码为4个base64中的字符。\n由于数据中的字节数不一定是3的整数倍，当字节数对3求模后，多1个字节时，那个字节会被编码为2个字符加2个=号(填充字符)，多2个字节时，这2个字节会被编码为3个字符加1个=号(填充字符)，刚好整除时，则不需要=号填充，具体规则如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/3629585-0622cbb7c0c2fd86.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp",alt:"img"}})]),a._v(" "),s("p",[a._v("image_2021-09-05_base64_codec.jpg")]),a._v(" "),s("p",[a._v("Linux下可以使用base64这个命令做base64编解码")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 3个字母等于3个字节，所以会编码为4个base64字符，并没有=号")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" -n abc "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" base64\nYWJj \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 1个字节会被编码为2个base64字符，另加2个=号填充")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" -n a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" base64\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("YQ")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 2个字节会被编码为3个base64字符，另加1个=号填充")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" -n ab"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v("base64\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("YWI")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 解码base64数据")]),a._v("\n$ "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("echo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("YWI")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" base64 -d\nab\n")])])]),s("p",[a._v("另外，base64编码有一些常见的变种，以下3种是常见的：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("MimeBase64\n每76个字符后会添加换行符"),s("code",[a._v("\\r\\n")]),a._v("，便于阅读。")])]),a._v(" "),s("li",[s("p",[a._v("UrlBase64\n由于Base64编码使用了"),s("code",[a._v("+ /")]),a._v("两个字符，这与url命名规则冲突("),s("code",[a._v("/")]),a._v("在url中是路径分隔符，"),s("code",[a._v("+")]),a._v("会被urldecode为空格字符)，这个变种将"),s("code",[a._v("+ /")]),a._v("这两个字符更换为"),s("code",[a._v("- _")]),a._v("，如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/3629585-ac692c08d834d716.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp",alt:"img"}})]),a._v(" "),s("p",[a._v("image_2021-09-05_base64_urlsafe_codec.jpg")])]),a._v(" "),s("li",[s("p",[a._v("NoPaddingBase64\n由于Base64编码是对6bit进行编码，数据以8bit存储，当字节数不是3的整数倍时需要=号填充，这种方案就是去掉了=号，从上面的编码示例中也可以看出，加=号填充纯粹是为了保持base64编码字符串长度为4的整数倍，去掉=号其实不影响解析。")])])]),a._v(" "),s("h2",{attrs:{id:"urlencode编码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#urlencode编码"}},[a._v("#")]),a._v(" urlencode编码")]),a._v(" "),s("p",[a._v("urlencode编码，看名字就知道是设计用来给url编码的，对于"),s("code",[a._v("a-z")]),a._v("，"),s("code",[a._v("A-Z")]),a._v("，"),s("code",[a._v("0-9")]),a._v("，"),s("code",[a._v(".")]),a._v("，"),s("code",[a._v("-")]),a._v("和"),s("code",[a._v("_")]),a._v(" ，urlencode都不会做任何处理原样输出，而其它字节会被编码为"),s("code",[a._v("%xx")]),a._v("(16进制)的形式，其中"),s("code",[a._v("xx")]),a._v("就是这个字节对应的hex编码。")]),a._v(" "),s("p",[a._v("Linux下"),s("code",[a._v("gridsite-clients")]),a._v("包实现了urlencode命令，如下：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("$ "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sudo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("apt")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("install")]),a._v(" gridsite-clients\n$ urlencode "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'a b'")]),a._v("\na%20b\n$ urlencode -d a%20b\na b\n")])])]),s("p",[a._v("使用python也很容易实现urlencode，可将其定义为 Linux 命名别名，方便使用，如下：")]),a._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("alias")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("urlencode")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'python -c \"import sys, urllib as ul; print ul.quote_plus(sys.argv[1])\"'")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("alias")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("urldecode")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'python -c \"import sys, urllib as ul; print ul.unquote_plus(sys.argv[1])\"'")]),a._v("\n")])])]),s("p",[a._v("另外，不同的urlencode实现上也有些差异，比如某些urlencode会将"),s("code",[a._v("空格")]),a._v("编码为"),s("code",[a._v("+")]),a._v("(W3C标准规定)，而另外一些实现中，"),s("code",[a._v("空格")]),a._v("会被编码为"),s("code",[a._v("%20")]),a._v("(RFC 2396)。")]),a._v(" "),s("blockquote",[s("p",[a._v("注：java中的URLEncoder、javascript中的encodeURIComponent、html表单提交中的application/x-www-form-urlencode，这些都会将空格编码为"),s("code",[a._v("+")]),a._v("，而一些web服务器在进行某些urldecode时会不认识"),s("code",[a._v("+")]),a._v("号，所以在使用这些函数进行urlencode编码时，最好将编码后的"),s("code",[a._v("+")]),a._v("替换为"),s("code",[a._v("%20")]),a._v("，如"),s("code",[a._v('URLEncoder.encode(bytes, "UTF-8").replace("+", "%20")')])])]),a._v(" "),s("h2",{attrs:{id:"两次urlencode解决乱码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两次urlencode解决乱码"}},[a._v("#")]),a._v(" 两次urlencode解决乱码")]),a._v(" "),s("p",[a._v("在最开始遇到乱码问题时，在网上搜到一种 “客户端两次urlencode，服务端一次urldecode” 的乱码解决方案，并声称这样能彻底解决乱码。\n然后很长一段时间我都是这样实践的，但一直不知道为什么，直到有一次我调试乱码问题调试到tomcat里面去才发现真相，原来web服务器对url都会自动做一次urldecode，urldecode后的字节使用server.xml中配置的uri-encoding字符编码转换成字符串，而如果uri-encoding这个字符编码配置与客户端使用的不同，就会出现乱码，下面用2个示例模拟一下：")]),a._v(" "),s("ol",[s("li",[a._v("客户端使用UTF-8进行一次urlencode，服务端tomcat使用uri-encoding的默认编码ISO-8859-1为例：")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" sendParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"好"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用UTF-8进行urlencode，'好'编码为 %E5%A5%BD")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeSendParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLEncoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("encode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("sendParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"UTF-8"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//....这里表示数据从客户端传至服务端")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeReceivedParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" urlencodeSendParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用ISO-8859-1进行urldecode后，%E5%A5%BD解码为乱码 å¥½ ，注意这个解码是web服务器自动进行的")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" receivedParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLDecoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("decode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("urlencodeReceivedParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ISO-8859-1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 会输出乱码 å¥½")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("receivedParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("ol",[s("li",[a._v("如果客户端做两次urlencode，服务端做一次urldecode，过程如下：")])]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" sendParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"好"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用UTF-8进行urlencode，'好'编码为%E5%A5%BD")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeSendParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLEncoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("encode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("sendParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"UTF-8"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 再使用UTF-8进行urlencode，%E5%A5%BD 编码为 %25E5%25A5%25BD")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeSendParam2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLEncoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("encode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("urlencodeSendParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"UTF-8"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//....这里表示数据从客户端传至服务端")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeReceivedParam2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" urlencodeSendParam2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用ISO-8859-1进行urldecode后，%25E5%25A5%25BD 解码为%E5%A5%BD，注意这个解码是web服务器自动进行的")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeReceivedParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLDecoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("decode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("urlencodeReceivedParam2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"ISO-8859-1"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使用UTF-8进行urldecode后，%E5%A5%BD解码为'好'")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" receivedParam "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("URLDecoder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("decode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("urlencodeReceivedParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"UTF-8"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 会输出正确的'好'字")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("receivedParam"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("从上面的两个示例中，应该不难看出，之所以前端2次编码，后端1次解码不会出现乱码，是因为前端在第1次urlencode后，数据就已经变成了纯英文，而纯英文先使用UTF-8的urlencode编码，再使用ISO-8859-1的urldecode解码，是可以完全还原数据的。另外，由于服务端的第二次urldecode是你自己写的，字符编码当然会和前端使用一致的UTF-8，故"),s("code",[a._v("好")]),a._v("字被无误的还原回来了。")]),a._v(" "),s("p",[a._v("为什么说英文可以先使用UTF-8的urlencode编码，再使用ISO-8859-1的urldecode解码呢？原因是java中的"),s("code",[a._v("URLEncoder")]),a._v("类其实是做了两件事，先使用字符编码将字符串转换为字节，然后对字节进行urlencode编码，因为urlencode算法本质作用就是将字节数据编码为等效的英文字符表示，只不过"),s("code",[a._v("URLEncoder")]),a._v("类将其封装为一步了，等效代码如下：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1. 使用字符编码，将字符串转换为字节串，因为urlencode是用来处理字节数据的")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" bytes"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getBytes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("charset"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2. 将字节数据，使用urlencode算法，编码为英文字符串")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" urlencodeStr "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("urlencode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("bytes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("而对于UTF-8与ISO-8859-1来说，它们都是兼容ASCII码的，所以对于纯英文的urlencode编解码，编码数据是可以正确解码的，不信你可以把ISO-8859-1变成UTF-16试试，由于UTF-16是不兼容ASCII的，所以上面的方案处理后依然为乱码。")]),a._v(" "),s("p",[a._v("ps，虽然这种方案基本可以完美解决乱码(基于大多数主流字符编码兼容ASCII)，但由于第二次urlencode编码又会将"),s("code",[a._v("%")]),a._v("编码为"),s("code",[a._v("%25")]),a._v("，使得数据体积增大不少，所以非必要情况下，还是不要滥用比较好，能都用UTF-8就都用UTF-8吧。我以前经历过的项目都比较奇葩，多种编码混搭，才导致我要如此了解编码机制"),s("code",[a._v("[-_-]")]),a._v("。")]),a._v(" "),s("h2",{attrs:{id:"这些编码有啥用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#这些编码有啥用"}},[a._v("#")]),a._v(" 这些编码有啥用？")]),a._v(" "),s("p",[a._v("这些编码的本质作用都是将字节数据转换为等效的纯英文形式，主要用在那些不方便查看、存储或传输原始字节数据的地方。\n比如在html中，因为html本身就是纯文本的，不能直接放入原始字节数据，这时，我们可以将一些小图标(非文本数据)通过base64编码的方式内嵌到html中，以使得html页面与图标数据能在一次网络交互中返回，这种方案也称Data URI。")]),a._v(" "),s("h2",{attrs:{id:"对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比"}},[a._v("#")]),a._v(" 对比")]),a._v(" "),s("ol",[s("li",[a._v("hex编码\n就算原文件是纯英文内容，编码后内容也和原文完全不一样，普通人难以阅读，但由于只有16个字符，听说一些程序员大牛能够记下他们的映射关系，从而达到读hex编码和读原文一样的效果。另外，数据在经过hex编码后，空间占用变成了原来的2倍。")]),a._v(" "),s("li",[a._v("base64编码\n由64个字符组成，比hex编码更难阅读，但由于每3个字节会被编码为4个字符，所以，空间占用会是原来的4/3，比hex要节省空间。另外要注意的是，虽然Base64编码后的数据难以阅读，但不能将其做为加密算法使用，因为它解码都不需要你提供密钥啊。")]),a._v(" "),s("li",[a._v("urlencode编码\n由于英文字符原样保留，对于以英文为主的内容，可读性最好，空间占用几乎不变，而对于非英文内容，每个字节会被编码为%xx的3个字符，空间占用是原来的3倍，所以urlencode是一个对英文友好的编码方案。")])]),a._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("p",[a._v("除了hex,base64,urlencode编码之外，其实还有base32,base58这样的编码，但它们只是编码方式不同罢了，本质作用是相同的，即"),s("code",[a._v("将字节数据转换为等效的纯英文表示，方便传输与存储")]),a._v("。"),s("a",{attrs:{href:"https://www.jianshu.com/p/4d701c09d44e",target:"_blank",rel:"noopener noreferrer"}},[a._v("链接"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);